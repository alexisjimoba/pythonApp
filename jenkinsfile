pipeline {
  agent any

  options {
    ansiColor('xterm'); timestamps(); disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '15'))
  }

  parameters {
    choice(name: 'ACTION', choices: ['deploy', 'destroy'], description: 'Acción')
    // Imagen YA existente (no se construye aquí)
    string(name: 'IMAGE_REPOSITORY', defaultValue: 'pythonapp', description: 'Repo de la imagen (registry/myproj/pythonapp)')
    string(name: 'IMAGE_TAG',        defaultValue: 'latest',    description: 'Tag de la imagen')

    // K8s / Helm
    string(name: 'NAMESPACE',     defaultValue: 'pythonapp',  description: 'Namespace destino')
    string(name: 'RELEASE_NAME',  defaultValue: 'pythonapp',  description: 'Nombre del release Helm')
    string(name: 'REPLICAS',      defaultValue: '1',          description: 'Réplicas')
    string(name: 'SERVICE_TYPE',  defaultValue: 'NodePort',   description: 'Service type (NodePort/ClusterIP)')
    string(name: 'SERVICE_PORT',  defaultValue: '80',         description: 'Service port (externo)')
    string(name: 'TARGET_PORT',   defaultValue: '8000',       description: 'Puerto del contenedor (app)')
    string(name: 'NODE_PORT',     defaultValue: '30080',      description: 'NodePort (si SERVICE_TYPE=NodePort)')
    booleanParam(name: 'INGRESS_ENABLED', defaultValue: false, description: 'Habilitar Ingress')
    string(name: 'INGRESS_HOST',  defaultValue: 'pythonapp.local', description: 'Host del Ingress')
  }

  stages {
    stage('Preflight') {
      steps {
        sh '''
          set -e
          for t in terraform helm git curl; do
            command -v $t >/dev/null || { echo "Falta $t en el agente Jenkins: $t"; exit 1; }
          done
        '''
      }
    }

    stage('Checkout infra repo') {
      steps { checkout scm }
    }

    stage('Terraform apply/destroy') {
      steps {
        withCredentials([
          string(credentialsId: 'K8S_HOST',        variable: 'TF_VAR_k8s_host'),
          string(credentialsId: 'K8S_CLUSTER_CA',  variable: 'TF_VAR_k8s_cluster_ca'),
          string(credentialsId: 'K8S_CLIENT_CERT', variable: 'TF_VAR_k8s_client_cert'),
          string(credentialsId: 'K8S_CLIENT_KEY',  variable: 'TF_VAR_k8s_client_key')
        ]) {
          withEnv([
            "TF_VAR_namespace=${params.NAMESPACE}",
            "TF_VAR_release_name=${params.RELEASE_NAME}",
            "TF_VAR_image_repository=${params.IMAGE_REPOSITORY}",
            "TF_VAR_image_tag=${params.IMAGE_TAG}",
            "TF_VAR_replicas=${params.REPLICAS}",
            "TF_VAR_service_type=${params.SERVICE_TYPE}",
            "TF_VAR_service_port=${params.SERVICE_PORT}",
            "TF_VAR_service_target_port=${params.TARGET_PORT}",
            "TF_VAR_node_port=${params.NODE_PORT}",
            "TF_VAR_ingress_enabled=${params.INGRESS_ENABLED}",
            "TF_VAR_ingress_host=${params.INGRESS_HOST}"
          ]) {
            sh '''
              set -e
              # Evita que el provider busque kubeconfig
              unset KUBECONFIG

              cd terraform
              terraform init -upgrade
              if [ "${ACTION}" = "destroy" ]; then
                terraform destroy -auto-approve
              else
                terraform apply -auto-approve
              fi
            '''
          }
        }
      }
    }

    stage('Post-deploy (opcional)') {
      when { expression { params.ACTION == 'deploy' } }
      steps {
        sh '''
          set -e
          echo "Despliegue aplicado. Si dispones de kubectl en el agente, puedes ejecutar checks manuales:"
          echo "  kubectl -n '${NAMESPACE}' get svc"
          echo "  kubectl -n '${NAMESPACE}' rollout status deploy/${RELEASE_NAME} --timeout=60s"
        '''
      }
    }
  }

  post {
    success { echo "Pipeline ${params.ACTION} OK." }
    failure { echo "Pipeline ${params.ACTION} falló." }
  }
}
