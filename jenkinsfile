pipeline {
  agent any

  options {
    timestamps()
    skipDefaultCheckout(true)
  }

  parameters {
    choice(name: 'TF_ACTION', choices: ['plan', 'apply', 'none'], description: 'AcciÃ³n de Terraform')
    choice(name: 'TF_ENV',    choices: ['staging', 'production', 'local'], description: 'Ambiente para tfvars')
    string(name: 'API_SERVER_HOST', defaultValue: '192.168.49.2', description: 'IP del API server (minikube ip)')
    string(name: 'API_SERVER_PORT', defaultValue: '8443', description: 'Puerto del API server')
  }

  environment {
    LOCAL_BIN     = "${WORKSPACE}/.bin"
    PATH          = "${WORKSPACE}/.bin:${PATH}"

    TF_WORKDIR    = 'terraform'
    TF_VERSION    = '1.6.6'

    TF_VAR_env    = 'dev'
    TF_VAR_region = 'us-central1'
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        script {
          def cmd = '''#!/bin/bash
            set -euxo pipefail
            echo "== Entorno ==" && printenv | sort
            which git  || true; git  --version  || true
            which curl || true
            which wget || true
            which jar  || true
            which python3 || true
          '''
          try { ansiColor('xterm') { sh cmd } } catch (ignored) { sh cmd }
        }
      }
    }

    stage('Setup Tooling (sin apt)') {
      steps {
        script {
          def cmd = '''#!/bin/bash
            set -euxo pipefail
            mkdir -p "${LOCAL_BIN}"

            # helper descarga (curl o wget)
            dl() { URL="$1"; OUT="$2";
              if command -v curl >/dev/null 2>&1; then curl -fsSL "$URL" -o "$OUT";
              elif command -v wget >/dev/null 2>&1; then wget -qO "$OUT" "$URL";
              else echo "âŒ No hay curl ni wget. Imposible descargar $URL"; return 1; fi; }

            ARCH=$(uname -m)
            if [ "$ARCH" = "x86_64" ] || [ "$ARCH" = "amd64" ]; then
              TSEC_URL="https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-amd64"
              TERRAFORM_ARCH="amd64"
              CKV_URL="https://github.com/bridgecrewio/checkov/releases/latest/download/checkov_Linux_x86_64"
            else
              TSEC_URL="https://github.com/aquasecurity/tfsec/releases/latest/download/tfsec-linux-arm64"
              TERRAFORM_ARCH="arm64"
              CKV_URL="https://github.com/bridgecrewio/checkov/releases/latest/download/checkov_Linux_arm64"
            fi

            # tfsec
            dl "$TSEC_URL" "${LOCAL_BIN}/tfsec" && chmod +x "${LOCAL_BIN}/tfsec" || true
            tfsec --version || echo "âš ï¸ tfsec no disponible"

            # terraform (zip) â†’ extraer con 'jar'
            TF_ZIP="terraform_${TF_VERSION}_linux_${TERRAFORM_ARCH}.zip"
            if dl "https://releases.hashicorp.com/terraform/${TF_VERSION}/${TF_ZIP}" "$TF_ZIP" && command -v jar >/dev/null 2>&1; then
              rm -rf .tfzip && mkdir .tfzip && (cd .tfzip && jar xf "../$TF_ZIP")
              mv .tfzip/terraform "${LOCAL_BIN}/terraform" || true
              rm -rf .tfzip "$TF_ZIP"
              chmod +x "${LOCAL_BIN}/terraform" || true
            else
              echo "âš ï¸ No se pudo extraer Terraform (falta jar o descarga fallÃ³)."
            fi
            terraform -version || echo "âš ï¸ terraform no disponible"

            # checkov (pip si hay python3; si no, binario)
            if command -v python3 >/dev/null 2>&1; then
              python3 -m pip install --no-cache-dir --upgrade pip || true
              python3 -m pip install --no-cache-dir checkov || true
            else
              if dl "$CKV_URL" "${LOCAL_BIN}/checkov"; then chmod +x "${LOCAL_BIN}/checkov"; fi
            fi
            checkov --version || echo "âš ï¸ checkov no disponible"
          '''
          try { ansiColor('xterm') { sh cmd } } catch (ignored) { sh cmd }
        }
      }
    }

    stage('Static Code Analysis: Terraform') {
      steps {
        script {
          def cmd = '''#!/bin/bash
            set -euxo pipefail
            mkdir -p reports

            TARGET="${TF_WORKDIR}"
            if [ ! -d "${TARGET}" ]; then
              if   [ -d "terraform" ];       then TARGET="terraform"
              elif [ -d "infra/terraform" ]; then TARGET="infra/terraform"
              else TARGET="."; fi
            fi

            # validate temprano (si hay Terraform)
            if command -v terraform >/dev/null 2>&1; then
              terraform -chdir="${TARGET}" init -backend=false -upgrade || true
              terraform -chdir="${TARGET}" validate || true
            fi

            if ! find "${TARGET}" -type f -name '*.tf' -print -quit | grep -q . ; then
              echo "â­ï¸  No hay archivos Terraform en ${TARGET}. Saltando escaneo IaC."
              exit 0
            fi

            echo "ðŸ”Ž Escaneando Terraform en: ${TARGET}"
            command -v tfsec   >/dev/null 2>&1 && tfsec   --soft-fail --format sarif --out reports/tfsec.sarif "${TARGET}" || true
            command -v tfsec   >/dev/null 2>&1 && tfsec   --soft-fail --format json  --out reports/tfsec.json  "${TARGET}" || true
            command -v checkov >/dev/null 2>&1 && checkov -d "${TARGET}" --soft-fail --output sarif    > reports/checkov.sarif || true
            command -v checkov >/dev/null 2>&1 && checkov -d "${TARGET}" --soft-fail --output junitxml > reports/checkov.junit.xml || true
          '''
          try { ansiColor('xterm') { sh cmd } } catch (ignored) { sh cmd }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'reports/*', fingerprint: true
          junit testResults: 'reports/checkov.junit.xml', allowEmptyResults: true
          echo "â„¹ï¸ Para visualizar SARIF en Jenkins, instala 'Warnings Next Generation' y agrega recordIssues + sarif()."
        }
      }
    }

    stage('Terraform Init/Plan/Apply') {
      when { expression { params.TF_ACTION != 'none' } }
      steps {
        script {
          withCredentials([file(credentialsId: 'kubeconfig-minikube', variable: 'KCF')]) {
            def cmd = '''#!/bin/bash
              set -euxo pipefail

              # Copia de kubeconfig (credencial) y forzado de host/puerto del API
              mkdir -p "${WORKSPACE}/.kube"
              export TF_VAR_kubeconfig_path="${WORKSPACE}/.kube/kubeconfig"
              cp "${KCF}" "${TF_VAR_kubeconfig_path}"

              # Si el kubeconfig apunta a 127.0.0.1, reescribe al host/puerto de parÃ¡metros
              if grep -qE '^\\s*server:\\s*https?://127\\.0\\.0\\.1' "${TF_VAR_kubeconfig_path}"; then
                sed -E "s#(^\\s*server:\\s*)https?://[^:]+:[0-9]+#\\1https://${API_SERVER_HOST}:${API_SERVER_PORT}#" -i "${TF_VAR_kubeconfig_path}" || true
              fi

              # Export para kubectl (si estuviera instalado) â€“ verificaciÃ³n opcional
              export KUBECONFIG="${TF_VAR_kubeconfig_path}"
              export KUBE_CONFIG_PATH="${TF_VAR_kubeconfig_path}"
              if command -v kubectl >/dev/null 2>&1; then
                kubectl --request-timeout=5s get ns || true
              fi

              # SelecciÃ³n de carpeta Terraform
              TARGET="${TF_WORKDIR}"
              if [ ! -d "${TARGET}" ]; then
                if   [ -d "terraform" ];       then TARGET="terraform"
                elif [ -d "infra/terraform" ]; then TARGET="infra/terraform"
                else echo "âŒ No se encontrÃ³ directorio Terraform."; exit 1; fi
              fi

              TFVARS=""
              if [ -f "${TARGET}/environments/${TF_ENV}/terraform.tfvars" ]; then
                TFVARS="-var-file=environments/${TF_ENV}/terraform.tfvars"
              fi

              echo "ðŸ“ Directorio: ${TARGET}"
              echo "ðŸŒ± Ambiente: ${TF_ENV}"
              echo "âš™ï¸  AcciÃ³n: ${TF_ACTION}"
              echo "ðŸ”— API server en kubeconfig: $(grep -m1 '^\\s*server:' "${TF_VAR_kubeconfig_path}")"

              terraform -chdir="${TARGET}" init -input=false -upgrade
              terraform -chdir="${TARGET}" validate
              terraform -chdir="${TARGET}" plan -input=false ${TFVARS} -out=tfplan

              if [ "${TF_ACTION}" = "apply" ]; then
                terraform -chdir="${TARGET}" apply -input=false -auto-approve tfplan
              fi

              # Exporta plan en JSON (Ãºtil para artefacto/PR)
              terraform -chdir="${TARGET}" show -json tfplan > "${WORKSPACE}/reports/tfplan.json" || true
            '''
            try { ansiColor('xterm') { sh cmd } } catch (ignored) { sh cmd }
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'reports/tfplan.json', fingerprint: true, onlyIfSuccessful: false
        }
      }
    }
  }

  post {
    success { echo "âœ… Pipeline OK (Terraform: ${params.TF_ACTION})." }
    always  { echo "ðŸ“¦ Reportes en 'reports/' (si hubo anÃ¡lisis/plan)." }
  }
}
