pipeline {
  agent any

  options {
    timestamps()
    skipDefaultCheckout(true)
  }

  parameters {
    choice(name: 'TF_ACTION', choices: ['plan', 'apply', 'none'], description: 'Acci√≥n de Terraform')
    choice(name: 'TF_ENV',    choices: ['staging', 'production', 'local'], description: 'Ambiente para tfvars')

    // API server accesible desde el contenedor (Windows: host.docker.internal)
    string(name: 'API_SERVER_HOST', defaultValue: 'host.docker.internal', description: 'Host del API server')
    string(name: 'API_SERVER_PORT', defaultValue: '49230', description: 'Puerto del API server')

    // Registro donde se har√° push
    choice(name: 'REGISTRY', choices: ['docker.io', 'ghcr.io'], description: 'Registro de contenedores')
    string(name: 'REPOSITORY', defaultValue: 'youruser/pythonapp', description: 'Repositorio (namespace/name). Ej: usuario/pythonapp')
    string(name: 'DOCKER_CRED_ID', defaultValue: 'docker-cred', description: 'ID credencial de Jenkins para el registry')

    // kubeconfig (credencial opcional o ruta montada en el contenedor)
    string(name: 'KUBE_CRED_ID',     defaultValue: '', description: 'ID credencial Secret file/text con kubeconfig (opcional)')
    string(name: 'KUBE_CONFIG_PATH', defaultValue: '/kubeconfig', description: 'Ruta kubeconfig en el agente (fallback)')
  }

  environment {
    LOCAL_BIN     = "${WORKSPACE}/.bin"
    PATH          = "${WORKSPACE}/.bin:${PATH}"

    TF_WORKDIR    = 'terraform'
    TF_VERSION    = '1.6.6'

    // Defaults Terraform (puedes ajustar)
    TF_VAR_env    = 'dev'
    TF_VAR_region = 'us-central1'

    // Donde copiaremos el kubeconfig para Terraform
    KUBECONFIG_PATH = "${WORKSPACE}/.kube/config"
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        sh 'git --version || true'
      }
    }

    stage('Docker Preflight') {
      steps {
        sh '''
          set -eu
          docker version
          echo "OK: docker CLI y socket disponibles."
        '''
      }
    }

    stage('Build & Tag Image') {
      steps {
        script {
          // Tag con SHA corto; si falla usa BUILD_NUMBER
          def sha = sh(returnStdout: true, script: 'git rev-parse --short HEAD || echo latest').trim()
          env.IMAGE_TAG  = sha
          env.IMAGE_NAME_LOCAL  = "pythonapp:${IMAGE_TAG}"
          env.IMAGE_NAME_REMOTE = "${params.REGISTRY}/${params.REPOSITORY}:${IMAGE_TAG}"
        }
        sh '''
          set -eu
          echo "üî® Construyendo imagen ${IMAGE_NAME_LOCAL}..."
          docker build -t "${IMAGE_NAME_LOCAL}" application
          docker tag "${IMAGE_NAME_LOCAL}" "${IMAGE_NAME_REMOTE}"
        '''
      }
    }

    stage('Login & Push Image') {
      steps {
        withCredentials([usernamePassword(credentialsId: params.DOCKER_CRED_ID, usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
          sh '''
            set -eu
            echo "$DOCKER_PASS" | docker login "${REGISTRY}" -u "$DOCKER_USER" --password-stdin
            echo "üì§ Pushing ${IMAGE_NAME_REMOTE}..."
            docker push "${IMAGE_NAME_REMOTE}"
            docker logout "${REGISTRY}" || true
          '''
        }
      }
    }

    stage('Prepare Kubeconfig (TLS best-effort)') {
      steps {
        script {
          def runPrep = { String kubePath ->
            withEnv(["KC_PATH=${kubePath}"]) {
              sh '''
                set -eu
                mkdir -p "$(dirname ${KUBECONFIG_PATH})"
                cp "${KC_PATH}" "${KUBECONFIG_PATH}"

                # Forzar server alcanzable desde el contenedor
                API_URL="https://${API_SERVER_HOST}:${API_SERVER_PORT}"
                sed -E 's#^([[:space:]]*server:[[:space:]]*).*$#\\1'"${API_URL}"'#' -i "${KUBECONFIG_PATH}"

                # Desactivar validaci√≥n TLS para evitar CN/SAN
                sed -E -i '/^[[:space:]]*certificate-authority(-data)?:/d' "${KUBECONFIG_PATH}"
                grep -q '^[[:space:]]*insecure-skip-tls-verify:' "${KUBECONFIG_PATH}" || \
                  sed -E -i '/^[[:space:]]*server:[[:space:]]*https?:\\/\\//a\\  insecure-skip-tls-verify: true' "${KUBECONFIG_PATH}"

                export KUBECONFIG="${KUBECONFIG_PATH}"
                echo "Ping API server..."
                curl -4 -k -m 5 -sS "${API_URL}/version" >/dev/null
              '''
            }
          }

          boolean used = false
          if (params.KUBE_CRED_ID?.trim()) {
            try {
              withCredentials([file(credentialsId: params.KUBE_CRED_ID, variable: 'KCF_FILE')]) {
                runPrep(KCF_FILE); used = true
              }
            } catch (ignore) {}
            if (!used) {
              withCredentials([string(credentialsId: params.KUBE_CRED_ID, variable: 'KCF_TEXT')]) {
                def kcPath = "${WORKSPACE}/.kube/kubeconfig_from_secret_text"
                writeFile file: kcPath, text: KCF_TEXT
                runPrep(kcPath); used = true
              }
            }
          }
          if (!used) {
            runPrep(params.KUBE_CONFIG_PATH)
          }
        }
      }
    }

    stage('Terraform Init/Plan/Apply') {
      when { expression { params.TF_ACTION != 'none' } }
      steps {
        script {
          // Pasamos repo/tag reales a Terraform ‚Üí Helm usar√° esta imagen
          env.TF_VAR_image_repository = "${params.REGISTRY}/${params.REPOSITORY}"
          env.TF_VAR_image_tag        = "${env.IMAGE_TAG}"
        }
        dir("${TF_WORKDIR}") {
          sh '''
            set -eu
            terraform init -upgrade
            terraform validate
            terraform plan -out=tfplan
            if [ "${TF_ACTION}" = "apply" ]; then
              terraform apply -auto-approve tfplan
            fi
          '''
        }
      }
    }
  }

  post {
    success { echo "‚úÖ Pipeline OK. Imagen publicada y Terraform ${params.TF_ACTION} listo." }
    failure { echo "‚ùå Fallo en el pipeline." }
  }
}
