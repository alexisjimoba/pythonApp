pipeline {
  agent any

  options {
    ansiColor('xterm')
    timestamps()
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  parameters {
    choice(name: 'ACTION', choices: ['deploy', 'destroy'], description: 'Acción a ejecutar')
    string(name: 'NAMESPACE', defaultValue: 'pythonapp', description: 'K8s namespace')
    string(name: 'RELEASE_NAME', defaultValue: 'pythonapp', description: 'Nombre de release Helm')
    string(name: 'IMAGE_REPOSITORY', defaultValue: 'pythonapp', description: 'Repositorio de imagen')
    string(name: 'IMAGE_TAG', defaultValue: 'latest', description: 'Tag de imagen')
    string(name: 'SERVICE_TYPE', defaultValue: 'NodePort', description: 'Tipo de Service')
    string(name: 'NODE_PORT', defaultValue: '30080', description: 'NodePort')
    booleanParam(name: 'INGRESS_ENABLED', defaultValue: false, description: 'Habilitar Ingress')
    string(name: 'INGRESS_HOST', defaultValue: 'pythonapp.local', description: 'Host de Ingress')
    string(name: 'REPLICAS', defaultValue: '1', description: 'Réplicas')
  }

  environment {
    // Necesitas un agente con Minikube, kubectl, Helm, Terraform y PowerShell
    POWERSHELL = isUnix() ? 'pwsh' : 'powershell'
  }

  stages {
    stage('Checkout infra repo') {
      steps {
        checkout scm
      }
    }

    stage('Preparar workspace') {
      steps {
        script {
          // Asegurar rutas
          env.PROJ_DIR = "${pwd()}"
          echo "Workspace: ${env.PROJ_DIR}"
        }
      }
    }

    stage('Deploy') {
      when { expression { params.ACTION == 'deploy' } }
      steps {
        script {
          withEnv([
            "TF_VAR_namespace=${params.NAMESPACE}",
            "TF_VAR_release_name=${params.RELEASE_NAME}",
            "TF_VAR_image_repository=${params.IMAGE_REPOSITORY}",
            "TF_VAR_image_tag=${params.IMAGE_TAG}",
            "TF_VAR_replicas=${params.REPLICAS}",
            "TF_VAR_service_type=${params.SERVICE_TYPE}",
            "TF_VAR_node_port=${params.NODE_PORT}",
            "TF_VAR_ingress_enabled=${params.INGRESS_ENABLED}",
            "TF_VAR_ingress_host=${params.INGRESS_HOST}"
          ]) {
            // Ejecuta script PowerShell que hace build + terraform apply
            bat(label: 'Deploy (Windows)',
                script: f'{POWERSHELL} -NoLogo -NoProfile -ExecutionPolicy Bypass -File ".\\scripts\\deploy.ps1" ' +
                        f'-Namespace "{params.NAMESPACE}" -ReleaseName "{params.RELEASE_NAME}" ' +
                        f'-ImageRepository "{params.IMAGE_REPOSITORY}" -ImageTag "{params.IMAGE_TAG}" ' +
                        f'-Replicas {params.REPLICAS} -ServiceType "{params.SERVICE_TYPE}" ' +
                        f'-NodePort {params.NODE_PORT} -IngressEnabled ${{params.INGRESS_ENABLED}} -IngressHost "{params.INGRESS_HOST}"'
            )
          }
        }
      }
    }

    stage('Destroy') {
      when { expression { params.ACTION == 'destroy' } }
      steps {
        dir('terraform') {
          bat(label: 'Terraform Destroy',
              script: f'{POWERSHELL} -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "terraform init; terraform destroy -auto-approve"')
        }
      }
    }
  }

  post {
    success {
      echo "Pipeline ${params.ACTION} completado."
    }
    failure {
      echo "Pipeline ${params.ACTION} falló."
    }
  }
}
