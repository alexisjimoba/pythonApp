pipeline {
  agent any

  options {
    skipDefaultCheckout(true)
    timestamps()
  }

  environment {
    APP_NAME      = 'mi-servicio'
    TF_WORKDIR    = 'infra/terraform'

    NODEJS_HOME   = tool name: 'node20', type: 'jenkins.plugins.nodejs.tools.NodeJSInstallation'
    PATH          = "${NODEJS_HOME}/bin:${PATH}"

    TF_VAR_env    = 'dev'
    TF_VAR_region = 'us-central1'

    SONARQUBE_ENV = 'SonarQubeServer' // si lo usas configurado en Jenkins
    SONAR_PROJECT = 'org:mi-servicio'
  }

  stages {
    stage('Checkout') {
      steps {
        ansiColor('xterm') {
          checkout([$class: 'GitSCM',
            branches: [[name: '*/main']],
            userRemoteConfigs: [[url: 'https://github.com/tu-org/tu-repo.git', credentialsId: 'git-cred']],
            extensions: [[$class: 'SubmoduleOption', recursiveSubmodules: true]]
          ])
          sh 'echo "== Entorno ==" && printenv | sort'
        }
      }
    }

    stage('Setup Tooling') {
      steps {
        ansiColor('xterm') {
          sh '''
            set -euxo pipefail

            curl -sSL https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
            tfsec --version

            python3 -m venv .venv
            . .venv/bin/activate
            pip install --upgrade pip
            pip install checkov
            checkov --version

            if [ -f package.json ]; then
              npm ci || npm i
              npx eslint -v || npm i -D eslint
            fi
          '''
        }
      }
    }

    stage('Static Code Analysis: Terraform') {
      steps {
        ansiColor('xterm') {
          sh '''
            set -euxo pipefail
            mkdir -p reports

            tfsec --soft-fail --format sarif --out reports/tfsec.sarif ${TF_WORKDIR}
            tfsec --soft-fail --format json  --out reports/tfsec.json  ${TF_WORKDIR}

            . .venv/bin/activate
            checkov -d ${TF_WORKDIR} --soft-fail --output sarif    > reports/checkov.sarif
            checkov -d ${TF_WORKDIR} --soft-fail --output junitxml > reports/checkov.junit.xml
          '''
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'reports/*', fingerprint: true
          junit testResults: 'reports/checkov.junit.xml', allowEmptyResults: true
          script {
            try {
              recordIssues enabledForFailure: true, tools: [sarif(pattern: 'reports/*.sarif')]
            } catch (err) {
              echo "recordIssues no disponible (plugin faltante?): ${err}"
            }
          }
        }
      }
    }

    stage('Optional: App Scan (ESLint/Sonar)') {
      when {
        anyOf {
          expression { fileExists('package.json') }
          expression { fileExists('sonar-project.properties') }
        }
      }
      steps {
        ansiColor('xterm') {
          sh '''
            set -euxo pipefail
            mkdir -p reports

            if [ -f package.json ]; then
              npx eslint . -f junit -o reports/eslint.junit.xml || true
            fi
          '''
          script {
            try {
              withSonarQubeEnv("${SONARQUBE_ENV}") {
                sh '''
                  if [ -f sonar-project.properties ] && command -v sonar-scanner >/dev/null 2>&1; then
                    sonar-scanner -Dsonar.projectKey="${SONAR_PROJECT}"
                  else
                    echo "sonar-scanner o sonar-project.properties no disponibles; omitiendo SonarQube"
                  fi
                '''
              }
            } catch (err) {
              echo "SonarQube no configurado: ${err}"
            }
          }
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'reports/*', fingerprint: true
          junit testResults: 'reports/eslint.junit.xml', allowEmptyResults: true
        }
      }
    }
  }

  post {
    success { echo "âœ… AnÃ¡lisis estÃ¡tico completado." }
    always  { echo "ðŸ“¦ Reportes en el directorio 'reports/'." }
  }
}
